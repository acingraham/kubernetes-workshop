<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Kubernetes Intro Workshop</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Intro to Kubernetes Workshop</h3>
					<hr />
					<ul>
						<li>Go to <a href="https://bit.ly/mongo-kubernetes" target="_blank">bit.ly/mongo-kubernetes</a> to open these slides</li>
						<li>Once open, press &rarr; to go to the next slide and confirm you have all the dependencies installed for this workshop</li>
					</ul>
				</section>

				<section>
					<section>
						<h3>[1 of 4] Confirm Docker Desktop is installed</h3>
						<hr />
						<ul>
							<li>
								<p>Run the following command in your terminal:</p>
								<pre><code data-trim data-noescape>
									docker ps
								</code></pre>
							</li>
							<li>
								<p>You should see something like the following:</p>
								<img src="./assets/dockerps-success.png" alt="docker ps success"/>
							</li>
							<li>If so, click &rarr;. If not, click &darr; to troubleshoot.</li>
						</ul>
					</section>
					<section>
						<h3>Install Docker Desktop</h3>
						<hr />
						<ul>
							<li>Go to <a href="https://docs.docker.com/get-docker/" target="_blank">docs.docker.com/get-docker/</a> and follow the instructions to install Docker Desktop</li>
							<li>Once done, click &rarr;</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h3>[2 of 4] Enable Kubernetes on Docker Desktop</h3>
						<hr />
						<ul>
							<li>
								<p>Open the Docker Desktop Dashboard, go to Settings, and enable Kubernetes if it isn't already. Click <strong>Apply & restart</strong> after enabling. Press &darr; for more detailed instructions</p>
								<img src="./assets/DockerDesktopKubernetes.png" alt="Docker Desktop Enable Kubernetes" class="image-sm">
							</li>
						</ul>
					</section>
					<section>
						<h3>Enable Kubernetes on Docker Desktop</h3>
						<hr />
						<ul>
							<li>Go to <a href="https://docs.docker.com/desktop/kubernetes/" target="_blank">docs.docker.com/desktop/kubernetes/</a> and follow the instructions to enable Kubernetes on Docker Desktop</li>
							<li>Once done, click &rarr;</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h3>[3 of 4] Confirm kubectl is installed</h3>
						<hr />
						<ul>
							<li>
								<p>Run the following command in your terminal:</p>
								<pre><code data-trim data-noescape>
									kubectl get nodes
								</code></pre>
							</li>
							<li>
								<p>You should see something like the following:</p>
								<img src="./assets/KubectlGetNodesSuccess.png" alt="kubectl get nodes success"/>
							</li>
							<li>If so, click &rarr;. If not, click &darr; to troubleshoot.</li>
						</ul>
					</section>
					<section>
						<h3>Install kubectl</h3>
						<hr />
						<ul>
							<li>Go to <a href="https://kubernetes.io/docs/tasks/tools/#kubectl" target="_blank">kubernetes.io/docs/tasks/tools/#kubectl</a> and follow the instructions to install kubectl</li>
							<li>Once done, click &rarr;</li>
						</ul>
					</section>
				</section>

				<section>
					<h3>TODO - Should install both images once you have them (dark mode for rolling update demo)</h3>
					<h3>[4 of 4] Install the Coopernetes container we'll be using for examples</h3>
					<hr />

					<ul>
						<li>
							<p>Run the following command in your terminal:</p>
							<pre><code data-trim data-noescape>
								docker pull andrewingraham509/coopernetes:latest
							</code></pre>
						</li>
						<li>
							<p>You should see something like the following:</p>
							<img src="./assets/DockerPullSuccess.png" alt="docker pull success"/>
						</li>
						<li>If you run into an error, let me know! Otherwise, click &rarr;</li>
					</ul>
				</section>
	
				<section>
					<section>
						<h3>You're ready for the workshop!</h3>
						<hr />
						<p>We'll start shortly. While you wait, feel free to press &darr; repeatedly to learn some Kubernetes trivia.</p>
					</section>
					<section>
						<p><strong>Kubernetes</strong> is a Greek word meaning <strong>helmsman</strong> which is the person who steers a ship, the same way Kubernetes steers the containers it controls. Kubernetes was also chosen because it was a rarely Googled term.</p>
					</section>
					<section>
						<p>Kubernetes is based on Google's internal container orchestration project called <strong>Borg</strong></p>
					</section>
					<section>
						<p>The team originally wanted to call it <a href="https://en.wikipedia.org/wiki/Seven_of_Nine" target="_blank">Seven of Nine</a> as a reference to the Star Trek Borg drone, but trademarking wouldn't allow it</p>
						<img src="./assets/SevenOfNine.jpeg" alt="Seven of Nine Drone" class="image-sm" />
					</section>
					<section>
						<p>The wheel of a ship is called a <strong>helm</strong> and is where the Kubernetes logo comes from. Despite helms typically having 6 or 8 spokes, you'll notice the Kubernetes logo has 7. This is a reference to the "Seven of Nine" drone.</p>
						<img src="./assets/KubernetesLogo.png" alt="Kubernetes Logo" class="image-sm"/>
					</section>
					<section>
						Kubernetes is often shortened to k8s (pronounced "kates")
					</section>
					<section>
						<p>Want more Kubernetes lore? Here's a documentary on Kubernetes:</p>
						<p><iframe width="560" height="315" src="https://www.youtube.com/embed/BE77h7dmoQU?si=kegavaoulcPeGs5v" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe></p>
					</section>
				</section>

				<section>
					<h3>Overview</h3>
					<hr />
					<ol>
						<li>Intro to Kubernetes</li>
						<li>Kubernetes Architecture</li>
						<li>Demo Project and Kubernetes Fundamentals</li>
					</ol>
				</section>

				<section>
					<h3>1. Intro to Kubernetes</h3>
				</section>

				<section>
					<p>But before we get started with Kubernetes, let's cover some quick background information...</p>
				</section>

				<section>
					<section>
						<h3>Containers</h3>
						<hr />
						<ul>
							<li>A way to package code and all its dependencies so an application runs reliably from one environment to another</li>
							<li>Similar to Virtual Machines (VMs), containers provide benefits like resource isolation and allocation</li>
							<li>Unlike VMs, containers virtualize the operating system instead of the hardware</li>
							<li>This allows containers to be more portable and efficient</li>
							<li>Press &darr; for additional resources on Containers</li>
						</ul>
					</section>
					<section>
						<h3>Additional resources</h3>
						<hr />
						<ul>
							<li><a href="https://www.youtube.com/watch?v=0qotVMX-J5s" target="_blank">Containerization Explained</a></li>
							<li><a href="https://www.youtube.com/watch?v=cjXI-yxqGTI" target="_blank">Containers vs VMs: What's the difference?</a></li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h3>Docker</h3>
						<hr />
						<ul>
							<li>Docker is a software platform that allows you to build, test, and deploy applications quickly</li>
							<li>Docker packages software into containers</li>
							<li><a href="https://hub.docker.com/" target="_blank">Docker Hub</a> is the world's largest library and community for container images</li>
							<li>Press &darr; for additional resources on Docker</li>
						</ul>
					</section>
					<section>
						<h3>Additional resources</h3>
						<hr />
						<ul>
							<li><a href="https://www.youtube.com/watch?v=Gjnup-PuquQ" target="_blank">Docker in 100 Seconds</a></li>
							<li><a href="https://docs.docker.com/get-started/02_our_app/" target="_blank">Containerize an Application</a></li>
							<li><a href="https://learn.cantrill.io/p/docker-fundamentals" target="_blank">Docker Fundamentals Course</a></li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h3>Microservices</h3>
						<hr />
						<ul>
							<li>Microservices are an architectural and organizational approach to software development where software is composed of small, independent services</li>
							<li>The trend from monolithic architectures towards microservices caused an increased use of container technologies</li>
							<li>This resulted in applications that could be made up of lots and lots of containers</li>
							<li>Press &darr; for additional resources on microservices</li>
						</ul>
					</section>
					<section>
						<h3>Additional resources</h3>
						<hr />
						<ul>
							<li><a href="https://www.youtube.com/watch?v=CdBtNQZH8a4" target="_blank">What are Microservices?</a></li>
							<li><a href="https://www.youtube.com/watch?v=lTAcCNbJ7KE" target="_blank">What Are Microservices Really All About? (And When Not To Use It)</a></li>
						</ul>
					</section>
				</section>

				<section>
					<h3>TODO - customize this</h3>
					<h3>Intro to Kubernetes</h3>
					<hr />
					<ul>
						<li>Open source container orchestration tool</li>
						<li>Developed by Google</li>
						<li>Helps manage containerized applications in different deployment environments</li>
					</ul>
				</section>

				<section>
					<h3>TODO - describe situation of running microservices without Kubernetes</h3>
					<hr />
					<ul>
						<li>Open source container orchestration tool</li>
						<li>Developed by Google</li>
						<li>Helps manage containerized applications in different deployment environments</li>
					</ul>
				</section>

				<section>
					<h3>Kubernetes Benefits</h3>
					<hr />
					<ul>
						<li>High availability: </li>
						<li>Scalability: </li>
						<li>Disaster Recovery:</li>

						<hr />
						<li>Self healing</li>
						<li>Replicating architecture across environments (dev, prod)</li>
						<li>Replicating architecture across environments (AWS, Azure)</li>
						<li>Declarative syntax</li>
					</ul>
				</section>

				<section>
					<section>
						<h3>Kubernetes Costs</h3>
						<hr />
						<ul>
							<li>Increased Complexity</li>
							<li>Upfront cost</li>
							<li>Press &darr; for additional resources</li>
						</ul>
					</section>
					<section>
						<h3>Additional resources</h3>
						<hr />
						<ul>
							<li><a href="https://www.youtube.com/watch?v=H5sPGruv2yc" target="_blank">You Don’t Need Kubernetes</a></li>
						</ul>
					</section>
				</section>

				<section>
					<h3>Motivation</h3>
					<p>
						When to use
						When not to use
						Additional Resources
							- Theo's not to use kubernetes video
					</p>
				</section>

				<section>
					<h3>Architecture</h3>
					<p>
						When to use
						When not to use
						Additional Resources
							- ByteByteGo's short architecture video
					</p>
				</section>

				<section>
					Cluster
					Cluster is made up of Nodes. A Node is just a physical or virtual machine that is set up to run Pods.
					Pods
						Pods are the smallest deployable units of computing that you can create and manage in Kubernetes.
						Lightweight abstraction over container
						Makes Kubernetes container runtime agnostic (maybe?)
						Typically 1-to-1 with container. Meaning we'll usually only run 1 container within a Pod. We might include some sidecar containers in the same Pod.
							- Any ideas why this is the standard?
						Ephemeral. Can die very easily.
	
					Typically 2 Types of Nodes. Control plane nodes and worker nodes. TODO - Is the control plane actually running on Nodes? I think this is false.
					Control Plane
						Control plane is the brains of Kubernetes
						Can be multiple nodes. Think of production. Usually going to be separated regionally.
						Components
							- API Server - Exposes the Kubernetes API and acts as the frontend for the control plane.
							- Controller Manager - has a variety of responsibilities. Some include:
								- Responsible for noticing and responding when nodes go down
								- Watches for Job objects that represent one-off tasks, then creates Pods to run those tasks to completion.
							- Scheduler
								- Watches for newly created Pods without an assigned Node and selects a Node for them to run on
								- Factors taken into account for scheduling decisions include: individual and collective resource requirements, hardware/software/policy constraints, affinity and anti-affinity specifications, data locality, inter-workload interference, and deadlines.
								- Intelligently assign new pods to most appropriate Node
							- etcd
								- etcd is a strongly consistent, distributed key-value store. Pre-dates Kubernetes and is used outside of Kubernetes.
								- Within Kubernetes, it'd used for
									- Configuration data
									- Status information
									- Info about Nodes and containers
									- With a backup of etcd... TODO - I think you can restore a cluster completely using an etcd backup

					Worker Nodes
						Where our application code runs
						What is running on worker node
							- kubelet
							- kubeproxy
					Virtual Network
						Basically turns the cluster into one giant machines
						Workers are usually

				</section>

				<section>What are Kubernetes components?</section>

				<section>
					<h3>Project - Coopernetes</h3>
					- Run project locally w/o Kubernetes and show off the behavior. Could run w/ Docker. If you don't run with Docker, press down to see how to run w/ Docker.
					- At the beginning we downloaded a couple of containers with this application
					- Lets use kubernetes to run it locally!
					<p>TODO - image of Cooper behind the Kubernetes logo w/ a sailor's hat</p>
				</section>

				<section>
					We're using Docker Desktop to run Kubernetes
					- Open Docker Desktop and show some basics (Containers and Images tabs)
					- Images are read-only, immutable templates that define how a container will be created. Containers are the runtime instance of an image.
					- What does it mean for Kubernetes to be running on Docker Desktop? TODO - Answer This
					- Note that Docker Desktop is only using 1 node for our entire Kubernetes cluster. Fine for our purposes, but obviously not what we'd do in production. A reminder that 
				</section>

				<section>
					kubectl
						- A Kubernetes command-line tool that allows you to interact with your Kubernetes cluster
						- TODO - Add meme about kubectl pronunciation
				</section>

				<section>
					kubectl cluster-info
						- Displays cluster info
						- Shows Kubernetes control plane and CoreDNS are running. CoreDNS is a DNS server that serves as the Kubernetes cluster DNS. Used for service discovery?
					kubectl get nodes
						- Gets information about the Nodes in our cluster
						- You should see (at least) one row with NAME of “docker-desktop”
						- Notice we only have the control plane node
						- If you don't see the docker-desktop node, make sure you enabled kubernetes in docker desktop and it completed restarting.
					kubectl config get-contexts
						- A Kubernetes context is a group of access parameters that define which cluster you're interacting with, which user you're using, and which namespace you're working in.
						- We want to make sure we're interacting with the Docker Desktop Kubernetes cluster
						- One row should have "*" in the CURRENT column.
						- If it isn't "docker-desktop", run `kubectl config use-context docker-desktop`
				</section>

				<section>
					Creating our first Pod!
						- Reminder: Pods are the smallest deployable units of computing that you can create and manage in Kubernetes. They're a thin abstraction over the container.
				</section>

				<section>
					kubectl run myfirstpod --image=andrewingraham509/coopernetes:latest
						- https://kubebyexample.com/learning-paths/application-development-kubernetes/lesson-1-running-containerized-applications-4
						- Fine for quick experimentation but not how we'll normally create Pods
				</section>

				<section>
					Manifest files
					- Describe Kubernetes objects
					- Kubernetes objects are... TODO
					- Declarative. We describe the desired state and Kubernetes makes changes to reach that state.
					- Required fields
						- apiVersion - Which version of the Kubernetes API you're using to create this object
						- kind - What kind of object you want to create
						- metadata - Data that helps uniquely identify the object, including a name string, UID, and optional namespace
						- spec - What state you desire for the object
					- https://kubernetes.io/docs/concepts/overview/working-with-objects/
					- Additional resources: https://kubernetes.io/docs/concepts/configuration/overview/
				</section>

				<section>
					To create a Pod, we need to create a Manifest / Configuration file (TODO - figure out name)
					- Go over writing YAML and the VS extension for this if you don't do it earlier
					- Configuration files can be written in JSON or YAML
					- 3 Parts to a configuration file. The first 2 parts are the metadata and specification (which differs based on the metadata). I said there were 3 parts. Where's the 3rd? That's the status of the configuration file. It's automatically generated and edited by Kubernetes.
					- TODO - Configuration file may be called a Manifest. Basing that off of https://kubebyexample.com/learning-paths/application-development-kubernetes/lesson-1-running-containerized-applications
					- Where does Kubernetes get this status information? etcd stores this information. What puts it in etcd? TODO - Answer this question.
					- YAML is super strict with indentation
				</section>
	
				<section>
					kubectl apply -f pod.yml
						- `kubectl apply -f` lets you send a file to the Kubernetes API Server
						- Kubernetes will read the file and store the configuration in the cluster store
						- The scheduler will then find a worker node to run the Pod
				</section>

				<section>
					kubectl get nodes
						- Should now see our Pod running! If you ran this command really quickly, you may not see it just yet.
				</section>

				<section>
					kubectl describe pod first-pod
						- This will give us more details about the pod
				</section>

				<section>
					kubectl exec first-pod -- /bin/ls
						- Executing commands within an existing Pod
						- https://kubebyexample.com/learning-paths/application-development-kubernetes/lesson-1-running-containerized-applications-4
				</section>

				<section>
					kubectl exec --stdin --tty first-pod -- /bin/sh
						- Connect a shell to an existing Pod
						- https://kubebyexample.com/learning-paths/application-development-kubernetes/lesson-1-running-containerized-applications-4
				</section>

				<section>
					Can't access Pod. What gives?
					- Virtual Network
					- Pods aren't exposed / accessible
				</section>

				<section>
					Service
						Used for creating a static ip address
						Lifecycles of pod and service are not connected
						Internal vs. External (are there other kinds?)
						Additional Resources:
							- https://kubernetes.io/docs/concepts/services-networking/service/
				</section>

				<section>
					kubectl get svc
				</section>

				<section>Defining the Service</section>

				<section>
					kubectl apply -f svc.yml
				</section>

				<section>
					kubectl get svc
						- CLUSTER-IP value is an IP address on the internal Kubernetes Pod network and is used by other Pods and applications running on the cluster
						- Since it's a NodePort Service, it can be accessed by connecting to any cluster node o port 31111 as specified in the PORT(S) column.
				</section>

				<section>
					kubectl describe svc first-svc
				</section>

				<section>kubectl delete svc first-svc</section>
				<section>kubectl delete pod first-pod</section>

				<section>Session affinity?</section>

				<section>
					Deployments
					- Blueprints / Templates
					- This is how you'll pretty much always be defining pods in practice
					- Remember how we said Kubernetes (or something TODO) is declarative? monitors the current state of the system along with the desired state and tries to keep them aligned.
				</section>

				<section>
					kubectl create deployment
					- Quickly create single-container Deployments and Services.
					- https://kubernetes.io/docs/concepts/configuration/overview/
				</section>
				<section>Ingress - better url for accessing site</section>
				<section>
					Self-healing - kill a pod and see it still works. May add the endpoint to crash the app
					- Try killing pod and show it will be brought back up
					- However, there is still downtime here. Move on to changing the number of replicas
				</section>
				<section>
					Increasing number of replicas. Redeploy.
					- Change YAML file and Redeploy
					- Note the additional pod
					- Try killing one now and confirm that the website is never down
					- Additionally, you can see the pod has been replaced.
					- This demonstrates another feature of the Service component - it acts as a load balancer, routing requests to the pods.
					- Emphasize that the way the Service knows which pods it can send requests to by the label
				</section>
				<section>
					Rolling update - dark mode version
						- Show that you may get a different pod response
				</section>
				<section>
					Session Affinity
						- What if we don't want our users to be getting responses from different Pods and switching between deployments mid-rollout?
						- 
						- https://kubernetes.io/docs/reference/networking/virtual-ips/#session-affinity
				</section>
				<section>ConfigMap - changing background color</section>
				<section>
					Secrets - TODO
					- base64 encoding
				</section>
				<section>Add database</section>
				<section>Why can't we use Deployments for replicating a database?</section>
				<section>
					Stateful Sets
					- What you'd use for stateful applications (like databases) within cluster
					- Takes care of replicating pods just like Deployments, but ensures synchronization of data betweens pods
					- Recommendation seems to be to avoid putting databases in your Kubernetes cluster and instead to place them outside. I _think_ Volume Claims are used to do this. Definitely research.
				</section>
				<section>
					Volumes?
					- could be local storage to cluster
					- could be external storage which is not part of the k8s cluster. This is recommended for production.
					- Kubernetes doesn't manage any data persistence. Handling things like replication and backup is our responsibility.
				</section>
				<section>Job - send a pet to Cooper at a scheduled time</section>
				<section>CronJob - send pets regularly to Cooper with a cronjob</section>
				<section>
					- Deploying to something like linode
				</section>
	
				<section>
					<h3>Additional Resources</h3>
					<hr />
					<ul>
						<li><a href="https://roadmap.sh/kubernetes" target="_blank">Roadmap.sh - Kubernetes Roadmap</a></li>
						<li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/" target="_blank">Kubernetes.io - Learn Kubernetes Basics</a></li>
						<li><a href="https://github.com/kelseyhightower/kubernetes-the-hard-way" target="_blank">Kubernetes the Hard Way</a></li>
					</ul>
				</section>

				<section>
					<h3>Feedback Form</h3>
					<hr />
				
				</section>

				<section>Thank you!</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
